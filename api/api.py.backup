from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel
import os
import psycopg2

app = FastAPI()
DATABASE_URL = os.environ.get("DATABASE_URL")

def get_connection():
    return psycopg2.connect(DATABASE_URL)

class Note(BaseModel):
    title: str
    content: str
    creator: str

@app.middleware("http")
async def enforce_json(request: Request, call_next):
    if request.method in ("POST", "PUT"):
        content_type = request.headers.get("content-type", "")
        if "application/json" not in content_type:
            return JSONResponse(status_code=415, content={"detail": "Only application/json requests are accepted"})
    response = await call_next(request)
    return response

@app.middleware("http")
async def enforce_methods(request: Request, call_next):
    if request.method not in ("GET", "POST", "PUT", "DELETE"):
        return JSONResponse(status_code=405, content={"detail": f"Method {request.method} not allowed"})
    response = await call_next(request)
    return response

@app.get("/")
def read_root():
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("SELECT NOW()")
    now = cur.fetchone()[0]
    cur.close()
    conn.close()
    return {"time": str(now)}

@app.get("/notes")
def get_notes_all():
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("SELECT id, title, content, creator, timestamp FROM notes")
    rows = cur.fetchall()
    cur.close()
    conn.close()
    return [{"id": r[0], "title": r[1], "content": r[2], "creator": r[3], "timestamp": r[4]} for r in rows]

@app.get("/notes/{id}")
def get_note(id: int):
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("SELECT id, title, content, creator, timestamp FROM notes WHERE id = %s", (id,))
    row = cur.fetchone()
    cur.close()
    conn.close()

    if row is None:
        raise HTTPException(status_code=404, detail="Note not found")
    
    return {"id": row[0], "title": row[1], "content": row[2], "creator": row[3], "timestamp": row[4]}

@app.post("/notes")
def create_note(note: Note):
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("INSERT INTO notes (title, content, creator) VALUES (%s, %s, %s) RETURNING id, title", (note.title, note.content, note.creator))
    new_notes = cur.fetchone()
    conn.commit()
    cur.close()
    conn.close()
    return {"message": "Note: {} was successfully created (id: {})".format(new_notes[1], new_notes[0])}

@app.put("/notes/{id}")
def update_note(id: int, note: Note):
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("UPDATE notes SET (title, content, creator) = (%s, %s, %s) WHERE id = %s RETURNING id, title", (note.title, note.content, note.creator, id,))
    updated_note = cur.fetchone()
    conn.commit()
    cur.close()
    conn.close()

    if updated_note is None:
        raise HTTPException(status_code=404, detail="Note not found")
    
    return {"message": "Note: {} was successfully updated (id: {})".format(updated_note[1], updated_note[0])}
    
@app.delete("/notes/{id}")
def delete_note(id: int):
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("DELETE FROM notes WHERE id = %s RETURNING id, title", (id,))
    deleted_note = cur.fetchone()
    conn.commit()
    cur.close()
    conn.close()

    if deleted_note is None:
        raise HTTPException(status_code=404, detail="Note not found")
    
    return {"message": "Note: {} was successfully deleted (id: {})".format(deleted_note[1], deleted_note[0])}